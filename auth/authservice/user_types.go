// Code generated by goagen v1.2.0, DO NOT EDIT.
//
// API "auth": Application User Types
//
// Command:
// $ goagen
// --design=github.com/fabric8-services/fabric8-auth/design
// --notool=true
// --out=$(GOPATH)/src/github.com/fabric8-services/fabric8-wit/auth
// --pkg=authservice
// --version=v1.2.0

package authservice

import (
	"github.com/goadesign/goa"
	uuid "github.com/goadesign/goa/uuid"
	"time"
)

// genericData user type.
type genericData struct {
	// UUID of the object
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Publicize creates GenericData from genericData
func (ut *genericData) Publicize() *GenericData {
	var pub GenericData
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = ut.Type
	}
	return &pub
}

// GenericData user type.
type GenericData struct {
	// UUID of the object
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// genericLinks user type.
type genericLinks struct {
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Publicize creates GenericLinks from genericLinks
func (ut *genericLinks) Publicize() *GenericLinks {
	var pub GenericLinks
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Related != nil {
		pub.Related = ut.Related
	}
	if ut.Self != nil {
		pub.Self = ut.Self
	}
	return &pub
}

// GenericLinks user type.
type GenericLinks struct {
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// identityData user type.
type identityData struct {
	// Attributes of the user identity
	Attributes *identityDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// unique id for the user identity
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user identity
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the identityData type instance.
func (ut *identityData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	return
}

// Publicize creates IdentityData from identityData
func (ut *identityData) Publicize() *IdentityData {
	var pub IdentityData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// IdentityData user type.
type IdentityData struct {
	// Attributes of the user identity
	Attributes *IdentityDataAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// unique id for the user identity
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user identity
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the IdentityData type instance.
func (ut *IdentityData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	return
}

// identityDataAttributes user type.
type identityDataAttributes struct {
	// The date of creation of the user
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The IDP provided this identity
	ProviderType *string `form:"providerType,omitempty" json:"providerType,omitempty" xml:"providerType,omitempty"`
	// The date of update of the user
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Publicize creates IdentityDataAttributes from identityDataAttributes
func (ut *identityDataAttributes) Publicize() *IdentityDataAttributes {
	var pub IdentityDataAttributes
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.ProviderType != nil {
		pub.ProviderType = ut.ProviderType
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Username != nil {
		pub.Username = ut.Username
	}
	return &pub
}

// IdentityDataAttributes user type.
type IdentityDataAttributes struct {
	// The date of creation of the user
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The IDP provided this identity
	ProviderType *string `form:"providerType,omitempty" json:"providerType,omitempty" xml:"providerType,omitempty"`
	// The date of update of the user
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Error objects provide additional information about problems encountered while
// performing an operation. Error objects MUST be returned as an array keyed by errors in the
// top level of a JSON API document.
//
// See. also http://jsonapi.org/format/#error-objects.
type jSONAPIError struct {
	// an application-specific error code, expressed as a string value.
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// a human-readable explanation specific to this occurrence of the problem.
	// Like title, this field’s value can be localized.
	Detail *string `form:"detail,omitempty" json:"detail,omitempty" xml:"detail,omitempty"`
	// a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// a links object containing the following members:
	// * about: a link that leads to further details about this particular occurrence of the problem.
	Links map[string]*jSONAPILink `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// a meta object containing non-standard meta-information about the error
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// an object containing references to the source of the error,
	// optionally including any of the following members
	//
	// * pointer: a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. "/data" for a primary data object,
	//            or "/data/attributes/title" for a specific attribute].
	// * parameter: a string indicating which URI query parameter caused the error.
	Source map[string]interface{} `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// the HTTP status code applicable to this problem, expressed as a string value.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// a short, human-readable summary of the problem that SHOULD NOT
	// change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
}

// Validate validates the jSONAPIError type instance.
func (ut *jSONAPIError) Validate() (err error) {
	if ut.Detail == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "detail"))
	}
	return
}

// Publicize creates JSONAPIError from jSONAPIError
func (ut *jSONAPIError) Publicize() *JSONAPIError {
	var pub JSONAPIError
	if ut.Code != nil {
		pub.Code = ut.Code
	}
	if ut.Detail != nil {
		pub.Detail = *ut.Detail
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = make(map[string]*JSONAPILink, len(ut.Links))
		for k2, v2 := range ut.Links {
			pubk2 := k2
			var pubv2 *JSONAPILink
			if v2 != nil {
				pubv2 = v2.Publicize()
			}
			pub.Links[pubk2] = pubv2
		}
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Source != nil {
		pub.Source = ut.Source
	}
	if ut.Status != nil {
		pub.Status = ut.Status
	}
	if ut.Title != nil {
		pub.Title = ut.Title
	}
	return &pub
}

// Error objects provide additional information about problems encountered while
// performing an operation. Error objects MUST be returned as an array keyed by errors in the
// top level of a JSON API document.
//
// See. also http://jsonapi.org/format/#error-objects.
type JSONAPIError struct {
	// an application-specific error code, expressed as a string value.
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// a human-readable explanation specific to this occurrence of the problem.
	// Like title, this field’s value can be localized.
	Detail string `form:"detail" json:"detail" xml:"detail"`
	// a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// a links object containing the following members:
	// * about: a link that leads to further details about this particular occurrence of the problem.
	Links map[string]*JSONAPILink `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// a meta object containing non-standard meta-information about the error
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// an object containing references to the source of the error,
	// optionally including any of the following members
	//
	// * pointer: a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. "/data" for a primary data object,
	//            or "/data/attributes/title" for a specific attribute].
	// * parameter: a string indicating which URI query parameter caused the error.
	Source map[string]interface{} `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// the HTTP status code applicable to this problem, expressed as a string value.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// a short, human-readable summary of the problem that SHOULD NOT
	// change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
}

// Validate validates the JSONAPIError type instance.
func (ut *JSONAPIError) Validate() (err error) {
	if ut.Detail == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "detail"))
	}
	return
}

// See also http://jsonapi.org/format/#document-links.
type jSONAPILink struct {
	// a string containing the link's URL.
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// a meta object containing non-standard meta-information about the link.
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates JSONAPILink from jSONAPILink
func (ut *jSONAPILink) Publicize() *JSONAPILink {
	var pub JSONAPILink
	if ut.Href != nil {
		pub.Href = ut.Href
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// See also http://jsonapi.org/format/#document-links.
type JSONAPILink struct {
	// a string containing the link's URL.
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// a meta object containing non-standard meta-information about the link.
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// refreshToken user type.
type refreshToken struct {
	// Refresh token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
}

// Publicize creates RefreshToken from refreshToken
func (ut *refreshToken) Publicize() *RefreshToken {
	var pub RefreshToken
	if ut.RefreshToken != nil {
		pub.RefreshToken = ut.RefreshToken
	}
	return &pub
}

// RefreshToken user type.
type RefreshToken struct {
	// Refresh token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
}

// relationGeneric user type.
type relationGeneric struct {
	Data  *genericData           `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates RelationGeneric from relationGeneric
func (ut *relationGeneric) Publicize() *RelationGeneric {
	var pub RelationGeneric
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationGeneric user type.
type RelationGeneric struct {
	Data  *GenericData           `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// relationGenericList user type.
type relationGenericList struct {
	Data  []*genericData         `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates RelationGenericList from relationGenericList
func (ut *relationGenericList) Publicize() *RelationGenericList {
	var pub RelationGenericList
	if ut.Data != nil {
		pub.Data = make([]*GenericData, len(ut.Data))
		for i2, elem2 := range ut.Data {
			pub.Data[i2] = elem2.Publicize()
		}
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationGenericList user type.
type RelationGenericList struct {
	Data  []*GenericData         `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// space user type.
type space struct {
	// ID of the space
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// Publicize creates Space from space
func (ut *space) Publicize() *Space {
	var pub Space
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	return &pub
}

// Space user type.
type Space struct {
	// ID of the space
	ID *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// spaceResourceData user type.
type spaceResourceData struct {
	// Keycloak Permission ID associated with this Space
	PermissionID *string `form:"permissionID,omitempty" json:"permissionID,omitempty" xml:"permissionID,omitempty"`
	// Keycloak Policy ID associated with this Space
	PolicyID *string `form:"policyID,omitempty" json:"policyID,omitempty" xml:"policyID,omitempty"`
	// Keycloak Resource ID associated with this Space
	ResourceID *string `form:"resourceID,omitempty" json:"resourceID,omitempty" xml:"resourceID,omitempty"`
}

// Validate validates the spaceResourceData type instance.
func (ut *spaceResourceData) Validate() (err error) {
	if ut.ResourceID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "resourceID"))
	}
	if ut.PermissionID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "permissionID"))
	}
	if ut.PolicyID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "policyID"))
	}
	return
}

// Publicize creates SpaceResourceData from spaceResourceData
func (ut *spaceResourceData) Publicize() *SpaceResourceData {
	var pub SpaceResourceData
	if ut.PermissionID != nil {
		pub.PermissionID = *ut.PermissionID
	}
	if ut.PolicyID != nil {
		pub.PolicyID = *ut.PolicyID
	}
	if ut.ResourceID != nil {
		pub.ResourceID = *ut.ResourceID
	}
	return &pub
}

// SpaceResourceData user type.
type SpaceResourceData struct {
	// Keycloak Permission ID associated with this Space
	PermissionID string `form:"permissionID" json:"permissionID" xml:"permissionID"`
	// Keycloak Policy ID associated with this Space
	PolicyID string `form:"policyID" json:"policyID" xml:"policyID"`
	// Keycloak Resource ID associated with this Space
	ResourceID string `form:"resourceID" json:"resourceID" xml:"resourceID"`
}

// Validate validates the SpaceResourceData type instance.
func (ut *SpaceResourceData) Validate() (err error) {
	if ut.ResourceID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "resourceID"))
	}
	if ut.PermissionID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "permissionID"))
	}
	if ut.PolicyID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "policyID"))
	}
	return
}

// tokenData user type.
type tokenData struct {
	// Access token
	AccessToken *string `form:"access_token,omitempty" json:"access_token,omitempty" xml:"access_token,omitempty"`
	// Access token expires in seconds
	ExpiresIn *interface{} `form:"expires_in,omitempty" json:"expires_in,omitempty" xml:"expires_in,omitempty"`
	// Token is not valid if issued before this date
	NotBeforePolicy *interface{} `form:"not-before-policy,omitempty" json:"not-before-policy,omitempty" xml:"not-before-policy,omitempty"`
	// Refresh token expires in seconds
	RefreshExpiresIn *interface{} `form:"refresh_expires_in,omitempty" json:"refresh_expires_in,omitempty" xml:"refresh_expires_in,omitempty"`
	// Refresh token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
	// Token type
	TokenType *string `form:"token_type,omitempty" json:"token_type,omitempty" xml:"token_type,omitempty"`
}

// Validate validates the tokenData type instance.
func (ut *tokenData) Validate() (err error) {
	if ut.ExpiresIn == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "expires_in"))
	}
	if ut.RefreshExpiresIn == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "refresh_expires_in"))
	}
	if ut.NotBeforePolicy == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "not-before-policy"))
	}
	return
}

// Publicize creates TokenData from tokenData
func (ut *tokenData) Publicize() *TokenData {
	var pub TokenData
	if ut.AccessToken != nil {
		pub.AccessToken = ut.AccessToken
	}
	if ut.ExpiresIn != nil {
		pub.ExpiresIn = *ut.ExpiresIn
	}
	if ut.NotBeforePolicy != nil {
		pub.NotBeforePolicy = *ut.NotBeforePolicy
	}
	if ut.RefreshExpiresIn != nil {
		pub.RefreshExpiresIn = *ut.RefreshExpiresIn
	}
	if ut.RefreshToken != nil {
		pub.RefreshToken = ut.RefreshToken
	}
	if ut.TokenType != nil {
		pub.TokenType = ut.TokenType
	}
	return &pub
}

// TokenData user type.
type TokenData struct {
	// Access token
	AccessToken *string `form:"access_token,omitempty" json:"access_token,omitempty" xml:"access_token,omitempty"`
	// Access token expires in seconds
	ExpiresIn interface{} `form:"expires_in" json:"expires_in" xml:"expires_in"`
	// Token is not valid if issued before this date
	NotBeforePolicy interface{} `form:"not-before-policy" json:"not-before-policy" xml:"not-before-policy"`
	// Refresh token expires in seconds
	RefreshExpiresIn interface{} `form:"refresh_expires_in" json:"refresh_expires_in" xml:"refresh_expires_in"`
	// Refresh token
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty" xml:"refresh_token,omitempty"`
	// Token type
	TokenType *string `form:"token_type,omitempty" json:"token_type,omitempty" xml:"token_type,omitempty"`
}

// Validate validates the TokenData type instance.
func (ut *TokenData) Validate() (err error) {

	return
}

// updateIdentityDataAttributes user type.
type updateIdentityDataAttributes struct {
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// The email
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// The users full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// Complete the registration to proceed. This can only be set to true
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Publicize creates UpdateIdentityDataAttributes from updateIdentityDataAttributes
func (ut *updateIdentityDataAttributes) Publicize() *UpdateIdentityDataAttributes {
	var pub UpdateIdentityDataAttributes
	if ut.Bio != nil {
		pub.Bio = ut.Bio
	}
	if ut.Company != nil {
		pub.Company = ut.Company
	}
	if ut.ContextInformation != nil {
		pub.ContextInformation = ut.ContextInformation
	}
	if ut.Email != nil {
		pub.Email = ut.Email
	}
	if ut.FullName != nil {
		pub.FullName = ut.FullName
	}
	if ut.ImageURL != nil {
		pub.ImageURL = ut.ImageURL
	}
	if ut.RegistrationCompleted != nil {
		pub.RegistrationCompleted = ut.RegistrationCompleted
	}
	if ut.URL != nil {
		pub.URL = ut.URL
	}
	if ut.Username != nil {
		pub.Username = ut.Username
	}
	return &pub
}

// UpdateIdentityDataAttributes user type.
type UpdateIdentityDataAttributes struct {
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// The email
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// The users full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// Complete the registration to proceed. This can only be set to true
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// updateUserData user type.
type updateUserData struct {
	// Attributes of the user identity
	Attributes *updateIdentityDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	Links      *genericLinks                 `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user identity
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the updateUserData type instance.
func (ut *updateUserData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	return
}

// Publicize creates UpdateUserData from updateUserData
func (ut *updateUserData) Publicize() *UpdateUserData {
	var pub UpdateUserData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// UpdateUserData user type.
type UpdateUserData struct {
	// Attributes of the user identity
	Attributes *UpdateIdentityDataAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	Links      *GenericLinks                 `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user identity
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the UpdateUserData type instance.
func (ut *UpdateUserData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	return
}

// JSONAPI store for the data of a user identity ID. See also http://jsonapi.org/format/#document-resource-object
type updateUserID struct {
	// user identity ID
	ID   *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the updateUserID type instance.
func (ut *updateUserID) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if ut.Type != nil {
		if !(*ut.Type == "identities") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, *ut.Type, []interface{}{"identities"}))
		}
	}
	return
}

// Publicize creates UpdateUserID from updateUserID
func (ut *updateUserID) Publicize() *UpdateUserID {
	var pub UpdateUserID
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a user identity ID. See also http://jsonapi.org/format/#document-resource-object
type UpdateUserID struct {
	// user identity ID
	ID   string `form:"id" json:"id" xml:"id"`
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the UpdateUserID type instance.
func (ut *UpdateUserID) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.ID == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "id"))
	}
	if !(ut.Type == "identities") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`response.type`, ut.Type, []interface{}{"identities"}))
	}
	return
}

// userData user type.
type userData struct {
	// Attributes of the user
	Attributes *userDataAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// unique id for the user
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the userData type instance.
func (ut *userData) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	return
}

// Publicize creates UserData from userData
func (ut *userData) Publicize() *UserData {
	var pub UserData
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// UserData user type.
type UserData struct {
	// Attributes of the user
	Attributes *UserDataAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// unique id for the user
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// type of the user
	Type string `form:"type" json:"type" xml:"type"`
}

// Validate validates the UserData type instance.
func (ut *UserData) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "attributes"))
	}
	return
}

// userDataAttributes user type.
type userDataAttributes struct {
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// The date of creation of the user
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The email
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// The user's full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The id of the corresponding Identity
	IdentityID *string `form:"identityID,omitempty" json:"identityID,omitempty" xml:"identityID,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// The IDP provided this identity
	ProviderType *string `form:"providerType,omitempty" json:"providerType,omitempty" xml:"providerType,omitempty"`
	// Whether the registration has been completed
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The date of update of the user
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The id of the corresponding User
	UserID *string `form:"userID,omitempty" json:"userID,omitempty" xml:"userID,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// Publicize creates UserDataAttributes from userDataAttributes
func (ut *userDataAttributes) Publicize() *UserDataAttributes {
	var pub UserDataAttributes
	if ut.Bio != nil {
		pub.Bio = ut.Bio
	}
	if ut.Company != nil {
		pub.Company = ut.Company
	}
	if ut.ContextInformation != nil {
		pub.ContextInformation = ut.ContextInformation
	}
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Email != nil {
		pub.Email = ut.Email
	}
	if ut.FullName != nil {
		pub.FullName = ut.FullName
	}
	if ut.IdentityID != nil {
		pub.IdentityID = ut.IdentityID
	}
	if ut.ImageURL != nil {
		pub.ImageURL = ut.ImageURL
	}
	if ut.ProviderType != nil {
		pub.ProviderType = ut.ProviderType
	}
	if ut.RegistrationCompleted != nil {
		pub.RegistrationCompleted = ut.RegistrationCompleted
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.URL != nil {
		pub.URL = ut.URL
	}
	if ut.UserID != nil {
		pub.UserID = ut.UserID
	}
	if ut.Username != nil {
		pub.Username = ut.Username
	}
	return &pub
}

// UserDataAttributes user type.
type UserDataAttributes struct {
	// The bio
	Bio *string `form:"bio,omitempty" json:"bio,omitempty" xml:"bio,omitempty"`
	// The company
	Company *string `form:"company,omitempty" json:"company,omitempty" xml:"company,omitempty"`
	// User context information of any type as a json
	ContextInformation map[string]interface{} `form:"contextInformation,omitempty" json:"contextInformation,omitempty" xml:"contextInformation,omitempty"`
	// The date of creation of the user
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The email
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// The user's full name
	FullName *string `form:"fullName,omitempty" json:"fullName,omitempty" xml:"fullName,omitempty"`
	// The id of the corresponding Identity
	IdentityID *string `form:"identityID,omitempty" json:"identityID,omitempty" xml:"identityID,omitempty"`
	// The avatar image for the user
	ImageURL *string `form:"imageURL,omitempty" json:"imageURL,omitempty" xml:"imageURL,omitempty"`
	// The IDP provided this identity
	ProviderType *string `form:"providerType,omitempty" json:"providerType,omitempty" xml:"providerType,omitempty"`
	// Whether the registration has been completed
	RegistrationCompleted *bool `form:"registrationCompleted,omitempty" json:"registrationCompleted,omitempty" xml:"registrationCompleted,omitempty"`
	// The date of update of the user
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// The url
	URL *string `form:"url,omitempty" json:"url,omitempty" xml:"url,omitempty"`
	// The id of the corresponding User
	UserID *string `form:"userID,omitempty" json:"userID,omitempty" xml:"userID,omitempty"`
	// The username
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// userListMeta user type.
type userListMeta struct {
	TotalCount *int `form:"totalCount,omitempty" json:"totalCount,omitempty" xml:"totalCount,omitempty"`
}

// Validate validates the userListMeta type instance.
func (ut *userListMeta) Validate() (err error) {
	if ut.TotalCount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`response`, "totalCount"))
	}
	return
}

// Publicize creates UserListMeta from userListMeta
func (ut *userListMeta) Publicize() *UserListMeta {
	var pub UserListMeta
	if ut.TotalCount != nil {
		pub.TotalCount = *ut.TotalCount
	}
	return &pub
}

// UserListMeta user type.
type UserListMeta struct {
	TotalCount int `form:"totalCount" json:"totalCount" xml:"totalCount"`
}

// pagingLinks user type.
type pagingLinks struct {
	Filters *string `form:"filters,omitempty" json:"filters,omitempty" xml:"filters,omitempty"`
	First   *string `form:"first,omitempty" json:"first,omitempty" xml:"first,omitempty"`
	Last    *string `form:"last,omitempty" json:"last,omitempty" xml:"last,omitempty"`
	Next    *string `form:"next,omitempty" json:"next,omitempty" xml:"next,omitempty"`
	Prev    *string `form:"prev,omitempty" json:"prev,omitempty" xml:"prev,omitempty"`
}

// Publicize creates PagingLinks from pagingLinks
func (ut *pagingLinks) Publicize() *PagingLinks {
	var pub PagingLinks
	if ut.Filters != nil {
		pub.Filters = ut.Filters
	}
	if ut.First != nil {
		pub.First = ut.First
	}
	if ut.Last != nil {
		pub.Last = ut.Last
	}
	if ut.Next != nil {
		pub.Next = ut.Next
	}
	if ut.Prev != nil {
		pub.Prev = ut.Prev
	}
	return &pub
}

// PagingLinks user type.
type PagingLinks struct {
	Filters *string `form:"filters,omitempty" json:"filters,omitempty" xml:"filters,omitempty"`
	First   *string `form:"first,omitempty" json:"first,omitempty" xml:"first,omitempty"`
	Last    *string `form:"last,omitempty" json:"last,omitempty" xml:"last,omitempty"`
	Next    *string `form:"next,omitempty" json:"next,omitempty" xml:"next,omitempty"`
	Prev    *string `form:"prev,omitempty" json:"prev,omitempty" xml:"prev,omitempty"`
}
